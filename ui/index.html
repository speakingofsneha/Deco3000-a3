<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reframe</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Inter:wght@100..900&display=swap" rel="stylesheet" />
  <!-- Base Styles -->
  <link rel="stylesheet" href="/ui/styles/base.css" />
  <!-- Page-specific Styles -->
  <link rel="stylesheet" href="/ui/styles/upload.css" />
  <link rel="stylesheet" href="/ui/styles/loading.css" />
  <!-- Deck Styles -->
  <link rel="stylesheet" href="/ui/styles/deck-ui.css" />
  <link rel="stylesheet" href="/ui/styles/deck-slides.css" />
  <link rel="icon" type="image/png" href="/favicon.png" />
</head>
<body>
  <!-- Upload Screen -->
  <div id="upload-screen" class="upload-screen">    
    <main class="upload-content">
      <h1 class="upload-title">Welcome to Reframe</h1>
      <p class="upload-subtitle">How would you like to get started?</p>
      
      <div class="upload-area" id="upload-area">
        <div class="upload-icon">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 4V20M12 4L8 8M12 4L16 8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <label for="file-input" class="upload-label">Import Content</label>
        <p class="upload-description">Turn your pdf an engaging case study</p>
        <input type="file" id="file-input" class="upload-input" accept=".pdf" />
      </div>
      
      <button class="reframe-button" id="reframe-button" disabled>Reframe it</button>
      <div id="error-message" class="error-message screen-hidden"></div>
    </main>
  </div>

  <!-- Loading Screen -->
  <div id="loading-screen" class="loading-screen screen-hidden">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <h2 class="loading-title">Processing your document</h2>
      <p class="loading-message">This may take a few moments. Please wait while we generate your slide deck...</p>
    </div>
  </div>

  <!-- Deck Screen (reused from deck.html) -->
  <div id="deck-screen" class="screen-hidden">
    <header class="topbar">
      <div class="crumb">
        <span class="crumb__title" id="deck-title">Deck</span>
        <span class="crumb__sep">/</span>
        <span class="crumb__meta" id="deck-meta">10 slides</span>
      </div>
      <div class="actions">
        <div class="export-dropdown">
          <button class="btn btn--ghost" id="export-btn">Export</button>
          <div class="dropdown-menu" id="export-menu">
            <button class="dropdown-item" data-format="png">Export as PNG</button>
            <button class="dropdown-item" data-format="svg">Export as SVG</button>
          </div>
        </div>
      </div>
    </header>

    <main class="deck" id="deck">
      <!-- Slides will be rendered here -->
    </main>

    <footer class="bottom-toolbar">
      <div class="toolbar-group">
        <div class="background-dropdown">
          <button class="toolbar-btn" id="background-btn">
            <span>Background</span>
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <div class="toolbar-dropdown-menu" id="background-menu">
            <button class="toolbar-dropdown-item" data-theme="light">
              <span>Light Mode</span>
            </button>
            <button class="toolbar-dropdown-item" data-theme="dark">
              <span>Dark Mode</span>
            </button>
          </div>
        </div>
      </div>
    </footer>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // API base URL - use relative URLs to work with any domain/port
    const API_BASE_URL = '';

    // State management
    let selectedFile = null;
    let uploadedFilePath = null;

    // DOM elements
    const uploadScreen = document.getElementById('upload-screen');
    const loadingScreen = document.getElementById('loading-screen');
    const deckScreen = document.getElementById('deck-screen');
    const fileInput = document.getElementById('file-input');
    const uploadArea = document.getElementById('upload-area');
    const reframeButton = document.getElementById('reframe-button');
    const errorMessage = document.getElementById('error-message');

    // File input handling
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        handleFileSelection(file);
      }
    });

    // Drag and drop handling
    uploadArea.addEventListener('click', () => {
      fileInput.click();
    });

    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type === 'application/pdf') {
        handleFileSelection(file);
        fileInput.files = e.dataTransfer.files;
      } else {
        showError('Please upload a PDF file');
      }
    });

    function handleFileSelection(file) {
      if (file.type !== 'application/pdf') {
        showError('Please select a PDF file');
        return;
      }
      selectedFile = file;
      reframeButton.disabled = false;
      hideError();
    }

    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.classList.remove('screen-hidden');
    }

    function hideError() {
      errorMessage.classList.add('screen-hidden');
    }

    // Reframe button handler
    reframeButton.addEventListener('click', async () => {
      if (!selectedFile) return;

      hideError();
      reframeButton.disabled = true;
      
      try {
        // Show loading screen
        uploadScreen.classList.add('screen-hidden');
        loadingScreen.classList.remove('screen-hidden');

        // Step 1: Upload file
        const formData = new FormData();
        formData.append('file', selectedFile);

        const uploadResponse = await fetch(`${API_BASE_URL}/upload`, {
          method: 'POST',
          body: formData
        });

        if (!uploadResponse.ok) {
          const error = await uploadResponse.json();
          throw new Error(error.detail || 'Upload failed');
        }

        const uploadData = await uploadResponse.json();
        uploadedFilePath = uploadData.file_path;

        // Step 2: Process PDF
        const processFormData = new FormData();
        processFormData.append('pdf_path', uploadedFilePath);
        processFormData.append('max_chunks', '1000');
        processFormData.append('chunk_size', '500');
        processFormData.append('overlap', '50');

        const processResponse = await fetch(`${API_BASE_URL}/process`, {
          method: 'POST',
          body: processFormData
        });

        if (!processResponse.ok) {
          const error = await processResponse.json();
          throw new Error(error.detail || 'Processing failed');
        }

        const processData = await processResponse.json();

        if (!processData.success || !processData.slide_deck) {
          throw new Error(processData.message || 'Processing failed');
        }

        // Step 3: Render slides
        renderSlideDeck(processData.slide_deck);

      } catch (error) {
        console.error('Error:', error);
        showError(error.message || 'An error occurred. Please try again.');
        loadingScreen.classList.add('screen-hidden');
        uploadScreen.classList.remove('screen-hidden');
        reframeButton.disabled = false;
      }
    });

    function renderSlideDeck(slideDeck) {
      // Hide loading, show deck
      loadingScreen.classList.add('screen-hidden');
      deckScreen.classList.remove('screen-hidden');

      // Update deck title
      const pdfName = extractPdfName(slideDeck.source_pdf);
      document.getElementById('deck-title').textContent = pdfName;
      document.title = `${pdfName} - Slide Deck`;

      // Render slides
      const deckEl = document.getElementById('deck');
      deckEl.innerHTML = '';

      // Group slides by title to combine content
      const groupedSlides = groupSlidesByTitle(slideDeck.slides);
      const totalSlides = groupedSlides.length;
      updateSlideMeta(1, totalSlides);

      groupedSlides.forEach((slide, idx) => {
        const section = document.createElement('section');
        const isTitle = slide.type === 'title' && idx === 0;
        const savedTheme = localStorage.getItem('slide-theme') || 'light';
        section.className = 'slide slide--' + savedTheme + (isTitle ? ' slide--title' : '');

        if (isTitle) {
          const subtitle = (slide.content && slide.content[0] && slide.content[0].text) ? slide.content[0].text : '';
          section.innerHTML = `
            <div class="slide__canvas slide__canvas--${savedTheme}">
              <div class="title__wrap">
                <h1 class="title__heading">${escapeHtml(slide.title || '')}</h1>
                ${subtitle ? `<p class="title__subtitle">${escapeHtml(subtitle)}</p>` : ''}
              </div>
            </div>
          `;
        } else {
          const hasMedia = slide.metadata && slide.metadata.has_media === true;
          const isMediaSlide = slide.metadata && slide.metadata.is_media_slide === true;
          const layoutClass = hasMedia ? ' layout--media-above' : '';
          
          section.className += layoutClass;
          
          const mediaHtml = hasMedia ? '<div class="media-placeholder" aria-hidden="true"></div>' : '';
          
          section.innerHTML = `
            <div class="slide__canvas slide__canvas--${savedTheme}">
              <div class="slide__content">
                <div class="overline">${idx + 1} / ${totalSlides}</div>
                <h1 class="heading">${escapeHtml(slide.title || '')}</h1>
                ${mediaHtml}
                ${renderSlideContent(slide.content, isMediaSlide)}
              </div>
            </div>
          `;
        }
        deckEl.appendChild(section);
      });

      // Set up intersection observer and other deck functionality
      setTimeout(() => {
        setupSlideObserver();
        const savedTheme = localStorage.getItem('slide-theme') || 'light';
        applyThemeToSlides(savedTheme);
        setupDropdown();
        setupBackgroundToolbar();
      }, 300);
    }

    function extractPdfName(sourcePdf) {
      if (!sourcePdf) return 'slides';
      const pathParts = sourcePdf.split('/');
      const filename = pathParts[pathParts.length - 1];
      return filename.replace(/\.pdf$/i, '');
    }

    function groupSlidesByTitle(slides) {
      const grouped = [];
      const titleMap = new Map();
      
      slides.forEach(slide => {
        // Always keep title slides as-is
        if (slide.type === 'title') {
          grouped.push(slide);
          return;
        }
        
        const title = slide.title || '';
        
        // If we've seen this title before, combine content
        if (titleMap.has(title)) {
          const existingIndex = titleMap.get(title);
          const existingSlide = grouped[existingIndex];
          
          // Combine all content items
          const combinedContent = [...existingSlide.content, ...slide.content];
          
          // Merge metadata (keep first slide's metadata, but update has_media if any slide has it)
          const hasMedia = existingSlide.metadata?.has_media || slide.metadata?.has_media;
          const isMediaSlide = existingSlide.metadata?.is_media_slide || slide.metadata?.is_media_slide;
          
          grouped[existingIndex] = {
            ...existingSlide,
            content: combinedContent,
            metadata: {
              ...existingSlide.metadata,
              has_media: hasMedia,
              is_media_slide: isMediaSlide
            }
          };
        } else {
          // First time seeing this title, add to grouped
          grouped.push(slide);
          titleMap.set(title, grouped.length - 1);
        }
      });
      
      return grouped;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function renderSlideContent(contentItems, isMediaSlide) {
      if (!contentItems || contentItems.length === 0) return '';
      
      if (isMediaSlide) {
        const descriptionText = contentItems.map(b => b.text || '').join(' ');
        return `<p class="body media-description">${escapeHtml(descriptionText)}</p>`;
      }
      
      // Show all content items, not limited to 3
      return `<div class="points">${contentItems.map(b => `<p class="point body">${escapeHtml(b.text || '')}</p>`).join('')}</div>`;
    }

    // Deck functionality (from deck.html)
    function escapeXml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    }

    function slideToSvg(slideElement) {
      const rect = slideElement.getBoundingClientRect();
      const width = Math.round(rect.width);
      const height = Math.round(rect.height);
      
      const styles = window.getComputedStyle(slideElement);
      const bgColor = styles.backgroundColor || '#ffffff';
      
      const svgTextElements = [];
      const walker = document.createTreeWalker(
        slideElement,
        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
        null
      );
      
      let node;
      const processedTextNodes = new Set();
      
      while (node = walker.nextNode()) {
        if (node.nodeType === Node.TEXT_NODE && !processedTextNodes.has(node)) {
          processedTextNodes.add(node);
          const text = node.textContent.trim();
          if (text) {
            const parentElement = node.parentElement;
            if (parentElement) {
              const elementRect = parentElement.getBoundingClientRect();
              const slideRect = slideElement.getBoundingClientRect();
              
              if (elementRect.width > 0 && elementRect.height > 0) {
                const computedStyles = window.getComputedStyle(parentElement);
                const fontSize = parseFloat(computedStyles.fontSize) || 16;
                const fontFamily = computedStyles.fontFamily.split(',')[0].replace(/['"]/g, '').trim() || 'sans-serif';
                const fontWeight = computedStyles.fontWeight || 'normal';
                let fontStyle = computedStyles.fontStyle || 'normal';
                
                const tagName = parentElement.tagName?.toLowerCase();
                const className = parentElement.className || '';
                const isHeading = (tagName && ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) ||
                                 className.includes('heading') || className.includes('title__heading');
                
                if (isHeading) {
                  fontStyle = 'normal';
                }
                
                const color = computedStyles.color || '#000000';
                const textAlign = computedStyles.textAlign || 'left';
                const lineHeight = parseFloat(computedStyles.lineHeight) || fontSize * 1.5;
                
                const x = elementRect.left - slideRect.left;
                const y = elementRect.top - slideRect.top + fontSize;
                
                let textX = x;
                let anchor = 'start';
                if (textAlign === 'center') {
                  textX = x + (elementRect.width / 2);
                  anchor = 'middle';
                } else if (textAlign === 'right') {
                  textX = x + elementRect.width;
                  anchor = 'end';
                }
                
                const lines = text.split('\n').filter(line => line.trim());
                lines.forEach((line, index) => {
                  if (line.trim()) {
                    svgTextElements.push(
                      `<text x="${textX}" y="${y + (index * lineHeight)}" 
                        font-family="${fontFamily}" 
                        font-size="${fontSize}" 
                        font-weight="${fontWeight}" 
                        font-style="${fontStyle}"
                        fill="${color}"
                        text-anchor="${anchor}">${escapeXml(line.trim())}</text>`
                    );
                  }
                });
              }
            }
          }
        }
      }
      
      const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
<rect width="100%" height="100%" fill="${bgColor}"/>
${svgTextElements.join('\n')}
</svg>`;
      
      return svgContent;
    }

    async function exportSlides(format) {
      const slides = document.querySelectorAll('.slide');
      if (slides.length === 0) {
        alert('No slides to export');
        return;
      }

      const button = document.getElementById('export-btn');
      const originalText = button.textContent;
      button.textContent = 'Exporting...';
      button.disabled = true;
      closeDropdown();

      try {
        const zip = new JSZip();
        const promises = [];

        if (format === 'png') {
          for (let i = 0; i < slides.length; i++) {
            const slide = slides[i];
            const canvasPromise = html2canvas(slide, {
              backgroundColor: '#ffffff',
              scale: 2,
              useCORS: true,
              logging: false
            }).then(canvas => {
              return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                  zip.file(`slide ${i + 1}.png`, blob);
                  resolve();
                }, 'image/png');
              });
            });
            promises.push(canvasPromise);
          }
        } else if (format === 'svg') {
          for (let i = 0; i < slides.length; i++) {
            const slide = slides[i];
            const svgContent = slideToSvg(slide);
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            zip.file(`slide ${i + 1}.svg`, blob);
          }
        }

        await Promise.all(promises);

        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = url;
        const pdfName = document.getElementById('deck-title').textContent || 'slides';
        a.download = `${pdfName}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        button.textContent = 'Exported!';
        setTimeout(() => {
          button.textContent = originalText;
          button.disabled = false;
        }, 2000);
      } catch (error) {
        console.error('Export failed:', error);
        alert('Export failed: ' + error.message);
        button.textContent = originalText;
        button.disabled = false;
      }
    }

    function toggleDropdown() {
      const menu = document.getElementById('export-menu');
      menu.classList.toggle('show');
    }

    function closeDropdown() {
      const menu = document.getElementById('export-menu');
      menu.classList.remove('show');
    }

    function updateSlideMeta(currentSlide, totalSlides) {
      const metaEl = document.getElementById('deck-meta');
      if (metaEl) {
        metaEl.textContent = `Section ${currentSlide} of ${totalSlides}`;
      }
    }

    function setupSlideObserver() {
      const slides = document.querySelectorAll('.slide');
      if (slides.length === 0) {
        return;
      }

      function updateActiveSlide() {
        const viewportCenter = window.innerHeight / 2;
        let activeSlide = null;
        let minDistance = Infinity;

        slides.forEach((slide) => {
          const rect = slide.getBoundingClientRect();
          const slideCenter = rect.top + (rect.height / 2);
          const distance = Math.abs(slideCenter - viewportCenter);

          if (rect.top < window.innerHeight && rect.bottom > 0) {
            if (distance < minDistance) {
              minDistance = distance;
              activeSlide = slide;
            }
          }
        });

        if (!activeSlide) {
          slides.forEach((slide) => {
            const rect = slide.getBoundingClientRect();
            if (rect.top >= 0 && rect.top < window.innerHeight) {
              if (!activeSlide) {
                activeSlide = slide;
              }
            }
          });
        }

        slides.forEach(slide => {
          slide.classList.remove('slide--active');
        });

        if (activeSlide) {
          activeSlide.classList.add('slide--active');
          const slideIndex = Array.from(slides).indexOf(activeSlide) + 1;
          updateSlideMeta(slideIndex, slides.length);
        } else if (slides.length > 0) {
          slides[0].classList.add('slide--active');
          updateSlideMeta(1, slides.length);
        }
      }

      let scrollTimeout;
      const handleScroll = () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(updateActiveSlide, 10);
      };
      
      window.addEventListener('scroll', handleScroll, { passive: true });
      window.addEventListener('resize', handleScroll, { passive: true });

      if (slides.length > 0) {
        slides[0].classList.add('slide--active');
        updateSlideMeta(1, slides.length);
      }
      
      setTimeout(() => {
        updateActiveSlide();
      }, 100);
      
      setTimeout(() => {
        updateActiveSlide();
      }, 500);
    }

    function setupDropdown() {
      document.addEventListener('click', (e) => {
        const dropdown = document.querySelector('.export-dropdown');
        if (dropdown && !dropdown.contains(e.target)) {
          closeDropdown();
        }
      });

      const exportBtn = document.getElementById('export-btn');
      if (exportBtn) {
        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleDropdown();
        });
      }

      document.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          const format = item.getAttribute('data-format');
          exportSlides(format);
        });
      });
    }

    function applyThemeToSlides(theme) {
      const slides = document.querySelectorAll('.slide');
      const slideCanvases = document.querySelectorAll('.slide__canvas');
      
      slides.forEach(slide => {
        if (theme === 'dark') {
          slide.classList.add('slide--dark');
          slide.classList.remove('slide--light');
        } else {
          slide.classList.remove('slide--dark');
          slide.classList.add('slide--light');
        }
      });

      slideCanvases.forEach(canvas => {
        if (theme === 'dark') {
          canvas.classList.add('slide__canvas--dark');
          canvas.classList.remove('slide__canvas--light');
        } else {
          canvas.classList.remove('slide__canvas--dark');
          canvas.classList.add('slide__canvas--light');
        }
      });
    }

    function setupBackgroundToolbar() {
      const backgroundBtn = document.getElementById('background-btn');
      const backgroundMenu = document.getElementById('background-menu');
      let currentTheme = localStorage.getItem('slide-theme') || 'light';

      applyThemeToSlides(currentTheme);
      updateDropdownStates(currentTheme);

      function toggleBackgroundMenu() {
        backgroundMenu.classList.toggle('show');
      }

      function closeBackgroundMenu() {
        backgroundMenu.classList.remove('show');
      }

      function updateDropdownStates(theme) {
        document.querySelectorAll('.toolbar-dropdown-item').forEach(item => {
          if (item.getAttribute('data-theme') === theme) {
            item.classList.add('active');
          } else {
            item.classList.remove('active');
          }
        });
      }

      function applyTheme(theme) {
        applyThemeToSlides(theme);
        updateDropdownStates(theme);
        localStorage.setItem('slide-theme', theme);
        currentTheme = theme;
      }

      backgroundBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleBackgroundMenu();
      });

      document.querySelectorAll('.toolbar-dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          const theme = item.getAttribute('data-theme');
          applyTheme(theme);
          closeBackgroundMenu();
        });
      });

      document.addEventListener('click', (e) => {
        const dropdown = document.querySelector('.background-dropdown');
        if (dropdown && !dropdown.contains(e.target)) {
          closeBackgroundMenu();
        }
      });
    }
  </script>
</body>
</html>

