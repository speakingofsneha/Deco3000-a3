<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slide Deck</title>
  <link rel="stylesheet" href="./deck.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body class="app">
  <header class="topbar">
    <div class="crumb">
      <span class="crumb__title" id="deck-title">Deck</span>
      <span class="crumb__sep">/</span>
      <span class="crumb__meta" id="deck-meta">10 slides</span>
    </div>
    <div class="actions">
      <div class="export-dropdown">
        <button class="btn btn--ghost" id="export-btn">Export</button>
        <div class="dropdown-menu" id="export-menu">
          <button class="dropdown-item" data-format="png">Export as PNG</button>
          <button class="dropdown-item" data-format="svg">Export as SVG</button>
        </div>
      </div>
    </div>
  </header>

  <main class="deck" id="deck"></main>
  <script>
    let pdfName = 'slides'; // Default name if not found
    
    function extractPdfName(sourcePdf) {
      if (!sourcePdf) return 'slides';
      const pathParts = sourcePdf.split('/');
      const filename = pathParts[pathParts.length - 1];
      return filename.replace(/\.pdf$/i, '');
    }

    async function loadDeck() {
      const params = new URLSearchParams(window.location.search);
      const file = params.get('file') || '../outputs/latest.json';
      const deckEl = document.getElementById('deck');
      deckEl.innerHTML = '';
      try {
        const res = await fetch(file);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        
        // Extract PDF name from source_pdf
        pdfName = extractPdfName(data.source_pdf);
        
        // Update deck title and page title to show PDF name
        document.getElementById('deck-title').textContent = pdfName;
        document.title = `${pdfName} - Slide Deck`;
        document.getElementById('deck-meta').textContent = `${(data.slides||[]).length} slides`;

        (data.slides || []).forEach((slide, idx) => {
          const section = document.createElement('section');
          const isTitle = slide.type === 'title' && idx === 0;
          section.className = 'slide' + (isTitle ? ' slide--title' : '');

          if (isTitle) {
            const subtitle = (slide.content && slide.content[0] && slide.content[0].text) ? slide.content[0].text : '';
            section.innerHTML = `
              <div class="slide__canvas">
                <div class="title__wrap">
                  <h1 class="title__heading">${slide.title || ''}</h1>
                  ${subtitle ? `<p class=\"title__subtitle\">${subtitle}</p>` : ''}
                </div>
              </div>
            `;
          } else {
            section.innerHTML = `
              <div class="slide__canvas">
                <div class="slide__content">
                  <div class="overline">${idx + 1} / ${(data.slides||[]).length}${slide.provenance && slide.provenance.length ? ' â€¢ ' + slide.provenance.join(', ') : ''}</div>
                  <h1 class="heading">${slide.title || ''}</h1>
                  ${(slide.content||[]).map(b => `<p class=\"body\">${b.text || ''}</p>`).join('')}
                </div>
              </div>
            `;
          }
          deckEl.appendChild(section);
        });
      } catch (e) {
        const section = document.createElement('section');
        section.className = 'slide';
        section.innerHTML = `<div class="slide__canvas"><div class="slide__content"><h1 class="heading">Failed to load</h1><p class="body">${e.message}</p></div></div>`;
        deckEl.appendChild(section);
      }
    }

    function escapeXml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    }

    function slideToSvg(slideElement) {
      const rect = slideElement.getBoundingClientRect();
      const width = Math.round(rect.width);
      const height = Math.round(rect.height);
      
      // Get background color
      const styles = window.getComputedStyle(slideElement);
      const bgColor = styles.backgroundColor || '#ffffff';
      
      // Collect all SVG text elements
      const svgTextElements = [];
      
      // Process all nodes in the slide
      const walker = document.createTreeWalker(
        slideElement,
        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
        null
      );
      
      let node;
      const processedTextNodes = new Set();
      
      while (node = walker.nextNode()) {
        if (node.nodeType === Node.TEXT_NODE && !processedTextNodes.has(node)) {
          processedTextNodes.add(node);
          const text = node.textContent.trim();
          if (text) {
            // Get the parent element for styling
            const parentElement = node.parentElement;
            if (parentElement) {
              const elementRect = parentElement.getBoundingClientRect();
              const slideRect = slideElement.getBoundingClientRect();
              
              if (elementRect.width > 0 && elementRect.height > 0) {
                const computedStyles = window.getComputedStyle(parentElement);
                const fontSize = parseFloat(computedStyles.fontSize) || 16;
                const fontFamily = computedStyles.fontFamily.split(',')[0].replace(/['"]/g, '').trim() || 'sans-serif';
                const fontWeight = computedStyles.fontWeight || 'normal';
                let fontStyle = computedStyles.fontStyle || 'normal';
                
                // Ensure headings are not italic - always set to normal for headings
                const tagName = parentElement.tagName?.toLowerCase();
                const className = parentElement.className || '';
                const isHeading = (tagName && ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) ||
                                 className.includes('heading') || className.includes('title__heading');
                
                if (isHeading) {
                  fontStyle = 'normal';
                }
                
                const color = computedStyles.color || '#000000';
                const textAlign = computedStyles.textAlign || 'left';
                const lineHeight = parseFloat(computedStyles.lineHeight) || fontSize * 1.5;
                
                // Calculate position
                const x = elementRect.left - slideRect.left;
                const y = elementRect.top - slideRect.top + fontSize;
                
                // Handle alignment
                let textX = x;
                let anchor = 'start';
                if (textAlign === 'center') {
                  textX = x + (elementRect.width / 2);
                  anchor = 'middle';
                } else if (textAlign === 'right') {
                  textX = x + elementRect.width;
                  anchor = 'end';
                }
                
                // Handle multi-line text
                const lines = text.split('\n').filter(line => line.trim());
                lines.forEach((line, index) => {
                  if (line.trim()) {
                    svgTextElements.push(
                      `<text x="${textX}" y="${y + (index * lineHeight)}" 
                        font-family="${fontFamily}" 
                        font-size="${fontSize}" 
                        font-weight="${fontWeight}" 
                        font-style="${fontStyle}"
                        fill="${color}"
                        text-anchor="${anchor}">${escapeXml(line.trim())}</text>`
                    );
                  }
                });
              }
            }
          }
        }
      }
      
      // Create SVG with text elements
      const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
<rect width="100%" height="100%" fill="${bgColor}"/>
${svgTextElements.join('\n')}
</svg>`;
      
      return svgContent;
    }

    async function exportSlides(format) {
      const slides = document.querySelectorAll('.slide');
      if (slides.length === 0) {
        alert('No slides to export');
        return;
      }

      const button = document.getElementById('export-btn');
      const originalText = button.textContent;
      button.textContent = 'Exporting...';
      button.disabled = true;
      closeDropdown();

      try {
        const zip = new JSZip();
        const promises = [];

        if (format === 'png') {
          for (let i = 0; i < slides.length; i++) {
            const slide = slides[i];
            const canvasPromise = html2canvas(slide, {
              backgroundColor: '#ffffff',
              scale: 2,
              useCORS: true,
              logging: false
            }).then(canvas => {
              return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                  zip.file(`slide ${i + 1}.png`, blob);
                  resolve();
                }, 'image/png');
              });
            });
            promises.push(canvasPromise);
          }
        } else if (format === 'svg') {
          for (let i = 0; i < slides.length; i++) {
            const slide = slides[i];
            const svgContent = slideToSvg(slide);
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            zip.file(`slide ${i + 1}.svg`, blob);
          }
        }

        await Promise.all(promises);

        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${pdfName}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        button.textContent = 'Exported!';
        setTimeout(() => {
          button.textContent = originalText;
          button.disabled = false;
        }, 2000);
      } catch (error) {
        console.error('Export failed:', error);
        alert('Export failed: ' + error.message);
        button.textContent = originalText;
        button.disabled = false;
      }
    }

    function toggleDropdown() {
      const menu = document.getElementById('export-menu');
      menu.classList.toggle('show');
    }

    function closeDropdown() {
      const menu = document.getElementById('export-menu');
      menu.classList.remove('show');
    }

    // Set up dropdown functionality
    function setupDropdown() {
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.querySelector('.export-dropdown');
        if (dropdown && !dropdown.contains(e.target)) {
          closeDropdown();
        }
      });

      const exportBtn = document.getElementById('export-btn');
      if (exportBtn) {
        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleDropdown();
        });
      }

      document.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          const format = item.getAttribute('data-format');
          exportSlides(format);
        });
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      loadDeck();
      setupDropdown();
    });
  </script>
</body>
</html>