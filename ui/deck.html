<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Deck</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Inter:wght@100..900&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./deck.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <link rel="icon" type="image/png" href="../favicon.png" />
</head>
<body class="app">
  <header class="topbar">
    <div class="crumb">
      <span class="crumb__title" id="deck-title">Deck</span>
      <span class="crumb__sep">/</span>
      <span class="crumb__meta" id="deck-meta">10 slides</span>
    </div>
    <div class="actions">
      <div class="export-dropdown">
        <button class="btn btn--ghost" id="export-btn">Export</button>
        <div class="dropdown-menu" id="export-menu">
          <button class="dropdown-item" data-format="png">Export as PNG</button>
          <button class="dropdown-item" data-format="svg">Export as SVG</button>
        </div>
      </div>
    </div>
  </header>

  <main class="deck" id="deck">
    <!-- ============================================
         Adaptive Points Layout Examples
         Uncomment these to see layout variants in action
         ============================================ -->
    
    <!-- 1) KEY STATEMENT - Single centered point -->
    <!--
    <section class="slide slide--light">
      <div class="slide__canvas">
        <div class="slide__content">
          <div class="overline">Example 1 / 9</div>
          <h2 class="heading">why current tools fail students</h2>
          <div class="points">
            <p class="point body">Current academic tools don't address the deep comprehension gap between reading and understanding complex material.</p>
          </div>
        </div>
      </div>
    </section>
    -->

    <!-- 2) TWO COLUMN DESCRIPTION - Side by side -->
    <!--
    <section class="slide slide--light">
      <div class="slide__canvas">
        <div class="slide__content">
          <div class="overline">Example 2 / 9</div>
          <h2 class="heading">the problem space</h2>
          <div class="points">
            <p class="point body">Students struggle with dense academic texts that require sustained focus and contextual understanding.</p>
            <p class="point body">Existing tools offer surface-level assistance without addressing deeper comprehension challenges.</p>
          </div>
        </div>
      </div>
    </section>
    -->

    <!-- 3) THREE CARDS - Default horizontal layout -->
    <!--
    <section class="slide slide--light">
      <div class="slide__canvas">
        <div class="slide__content">
          <div class="overline">Example 3 / 9</div>
          <h2 class="heading">key features</h2>
          <div class="points">
            <p class="point body">Interactive questioning that adapts to student responses in real-time.</p>
            <p class="point body">Context-aware explanations that reference specific passages and concepts.</p>
            <p class="point body">Progress tracking with personalized recommendations for improvement.</p>
          </div>
        </div>
      </div>
    </section>
    -->

    <!-- 3) THREE POINTS IN LIST - Vertical list with bullets (override) -->
    <!--
    <section class="slide slide--light layout--list-3">
      <div class="slide__canvas">
        <div class="slide__content">
          <div class="overline">Example 4 / 9</div>
          <h2 class="heading">methodology</h2>
          <div class="points">
            <p class="point body">First, we analyze the reading material for key concepts and relationships.</p>
            <p class="point body">Next, we generate adaptive questions based on the student's current understanding.</p>
            <p class="point body">Finally, we provide targeted feedback that builds comprehension progressively.</p>
          </div>
        </div>
      </div>
    </section>
    -->

    <!-- WITH MEDIA PLACEHOLDER - Example with optional media -->
    <!--
    <section class="slide slide--light">
      <div class="slide__canvas">
        <div class="slide__content">
          <div class="overline">Example 5 / 5</div>
          <h2 class="heading">system architecture</h2>
          <div class="points">
            <p class="point body">Frontend interface built with modern web technologies for responsive design.</p>
            <p class="point body">Backend API handles intelligent question generation and response processing.</p>
            <p class="point body">Database stores student progress and learning analytics for personalized insights.</p>
          </div>
          <div class="media-placeholder" aria-hidden="true"></div>
        </div>
      </div>
    </section>
    -->
  </main>

  <footer class="bottom-toolbar">
    <div class="toolbar-group">
      <div class="background-dropdown">
        <button class="toolbar-btn" id="background-btn">
          <span>Background</span>
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div class="toolbar-dropdown-menu" id="background-menu">
          <button class="toolbar-dropdown-item" data-theme="light">
            <span>Light Mode</span>
          </button>
          <button class="toolbar-dropdown-item" data-theme="dark">
            <span>Dark Mode</span>
          </button>
        </div>
      </div>
    </div>
  </footer>

  <script>
    let pdfName = 'slides'; // Default name if not found
    
    function extractPdfName(sourcePdf) {
      if (!sourcePdf) return 'slides';
      const pathParts = sourcePdf.split('/');
      const filename = pathParts[pathParts.length - 1];
      return filename.replace(/\.pdf$/i, '');
    }

    function renderSlideContent(contentItems) {
      if (!contentItems || contentItems.length === 0) return '';
      // Limit to maximum of 3 points per slide
      const limitedItems = contentItems.slice(0, 3);
      return `<div class="points">${limitedItems.map(b => `<p class="point body">${b.text || ''}</p>`).join('')}</div>`;
    }

    async function loadDeck() {
      const params = new URLSearchParams(window.location.search);
      const file = params.get('file') || '../outputs/latest.json';
      const deckEl = document.getElementById('deck');
      deckEl.innerHTML = '';
      try {
        const res = await fetch(file);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        
        // Extract PDF name from source_pdf
        pdfName = extractPdfName(data.source_pdf);
        
        // Update deck title and page title to show PDF name
        document.getElementById('deck-title').textContent = pdfName;
        document.title = `${pdfName} - Slide Deck`;
        const totalSlides = (data.slides||[]).length;
        updateSlideMeta(1, totalSlides);

        (data.slides || []).forEach((slide, idx) => {
          const section = document.createElement('section');
          const isTitle = slide.type === 'title' && idx === 0;
          const savedTheme = localStorage.getItem('slide-theme') || 'light';
          section.className = 'slide slide--' + savedTheme + (isTitle ? ' slide--title' : '');

          if (isTitle) {
            const subtitle = (slide.content && slide.content[0] && slide.content[0].text) ? slide.content[0].text : '';
            section.innerHTML = `
              <div class="slide__canvas slide__canvas--${savedTheme}">
                <div class="title__wrap">
                  <h1 class="title__heading">${slide.title || ''}</h1>
                  ${subtitle ? `<p class=\"title__subtitle\">${subtitle}</p>` : ''}
                </div>
              </div>
            `;
          } else {
            section.innerHTML = `
              <div class="slide__canvas slide__canvas--${savedTheme}">
                <div class="slide__content">
                  <div class="overline">${idx + 1} / ${(data.slides||[]).length}</div>
                  <h1 class="heading">${slide.title || ''}</h1>
                  ${renderSlideContent(slide.content)}
                </div>
              </div>
            `;
          }
          deckEl.appendChild(section);
        });
        
        // Set up intersection observer for slide opacity after a brief delay to ensure DOM is ready
        setTimeout(() => {
          setupSlideObserver();
          // Apply saved theme after slides are loaded
          const savedTheme = localStorage.getItem('slide-theme') || 'light';
          applyThemeToSlides(savedTheme);
        }, 300);
      } catch (e) {
        const section = document.createElement('section');
        section.className = 'slide';
        section.innerHTML = `<div class="slide__canvas"><div class="slide__content"><h1 class="heading">Failed to load</h1><p class="body">${e.message}</p></div></div>`;
        deckEl.appendChild(section);
      }
    }

    function escapeXml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    }

    function slideToSvg(slideElement) {
      const rect = slideElement.getBoundingClientRect();
      const width = Math.round(rect.width);
      const height = Math.round(rect.height);
      
      // Get background color
      const styles = window.getComputedStyle(slideElement);
      const bgColor = styles.backgroundColor || '#ffffff';
      
      // Collect all SVG text elements
      const svgTextElements = [];
      
      // Process all nodes in the slide
      const walker = document.createTreeWalker(
        slideElement,
        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
        null
      );
      
      let node;
      const processedTextNodes = new Set();
      
      while (node = walker.nextNode()) {
        if (node.nodeType === Node.TEXT_NODE && !processedTextNodes.has(node)) {
          processedTextNodes.add(node);
          const text = node.textContent.trim();
          if (text) {
            // Get the parent element for styling
            const parentElement = node.parentElement;
            if (parentElement) {
              const elementRect = parentElement.getBoundingClientRect();
              const slideRect = slideElement.getBoundingClientRect();
              
              if (elementRect.width > 0 && elementRect.height > 0) {
                const computedStyles = window.getComputedStyle(parentElement);
                const fontSize = parseFloat(computedStyles.fontSize) || 16;
                const fontFamily = computedStyles.fontFamily.split(',')[0].replace(/['"]/g, '').trim() || 'sans-serif';
                const fontWeight = computedStyles.fontWeight || 'normal';
                let fontStyle = computedStyles.fontStyle || 'normal';
                
                // Ensure headings are not italic - always set to normal for headings
                const tagName = parentElement.tagName?.toLowerCase();
                const className = parentElement.className || '';
                const isHeading = (tagName && ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) ||
                                 className.includes('heading') || className.includes('title__heading');
                
                if (isHeading) {
                  fontStyle = 'normal';
                }
                
                const color = computedStyles.color || '#000000';
                const textAlign = computedStyles.textAlign || 'left';
                const lineHeight = parseFloat(computedStyles.lineHeight) || fontSize * 1.5;
                
                // Calculate position
                const x = elementRect.left - slideRect.left;
                const y = elementRect.top - slideRect.top + fontSize;
                
                // Handle alignment
                let textX = x;
                let anchor = 'start';
                if (textAlign === 'center') {
                  textX = x + (elementRect.width / 2);
                  anchor = 'middle';
                } else if (textAlign === 'right') {
                  textX = x + elementRect.width;
                  anchor = 'end';
                }
                
                // Handle multi-line text
                const lines = text.split('\n').filter(line => line.trim());
                lines.forEach((line, index) => {
                  if (line.trim()) {
                    svgTextElements.push(
                      `<text x="${textX}" y="${y + (index * lineHeight)}" 
                        font-family="${fontFamily}" 
                        font-size="${fontSize}" 
                        font-weight="${fontWeight}" 
                        font-style="${fontStyle}"
                        fill="${color}"
                        text-anchor="${anchor}">${escapeXml(line.trim())}</text>`
                    );
                  }
                });
              }
            }
          }
        }
      }
      
      // Create SVG with text elements
      const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
<rect width="100%" height="100%" fill="${bgColor}"/>
${svgTextElements.join('\n')}
</svg>`;
      
      return svgContent;
    }

    async function exportSlides(format) {
      const slides = document.querySelectorAll('.slide');
      if (slides.length === 0) {
        alert('No slides to export');
        return;
      }

      const button = document.getElementById('export-btn');
      const originalText = button.textContent;
      button.textContent = 'Exporting...';
      button.disabled = true;
      closeDropdown();

      try {
        const zip = new JSZip();
        const promises = [];

        if (format === 'png') {
        for (let i = 0; i < slides.length; i++) {
          const slide = slides[i];
          const canvasPromise = html2canvas(slide, {
            backgroundColor: '#ffffff',
            scale: 2,
            useCORS: true,
            logging: false
          }).then(canvas => {
            return new Promise((resolve) => {
              canvas.toBlob((blob) => {
                zip.file(`slide ${i + 1}.png`, blob);
                resolve();
              }, 'image/png');
            });
          });
            promises.push(canvasPromise);
          }
        } else if (format === 'svg') {
          for (let i = 0; i < slides.length; i++) {
            const slide = slides[i];
            const svgContent = slideToSvg(slide);
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            zip.file(`slide ${i + 1}.svg`, blob);
          }
        }

        await Promise.all(promises);

        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${pdfName}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        button.textContent = 'Exported!';
        setTimeout(() => {
          button.textContent = originalText;
          button.disabled = false;
        }, 2000);
      } catch (error) {
        console.error('Export failed:', error);
        alert('Export failed: ' + error.message);
        button.textContent = originalText;
        button.disabled = false;
      }
    }

    function toggleDropdown() {
      const menu = document.getElementById('export-menu');
      menu.classList.toggle('show');
    }

    function closeDropdown() {
      const menu = document.getElementById('export-menu');
      menu.classList.remove('show');
    }

    function updateSlideMeta(currentSlide, totalSlides) {
      const metaEl = document.getElementById('deck-meta');
      if (metaEl) {
        metaEl.textContent = `Section ${currentSlide} of ${totalSlides}`;
      }
    }

    function setupSlideObserver() {
      const slides = document.querySelectorAll('.slide');
      if (slides.length === 0) {
        console.log('No slides found');
        return;
      }

      function updateActiveSlide() {
        const viewportCenter = window.innerHeight / 2;
        let activeSlide = null;
        let minDistance = Infinity;

        slides.forEach((slide) => {
          const rect = slide.getBoundingClientRect();
          const slideCenter = rect.top + (rect.height / 2);
          const distance = Math.abs(slideCenter - viewportCenter);

          // Check if slide is visible in viewport
          if (rect.top < window.innerHeight && rect.bottom > 0) {
            if (distance < minDistance) {
              minDistance = distance;
              activeSlide = slide;
            }
          }
        });

        // If no slide found, use the first visible slide
        if (!activeSlide) {
          slides.forEach((slide) => {
            const rect = slide.getBoundingClientRect();
            if (rect.top >= 0 && rect.top < window.innerHeight) {
              if (!activeSlide) {
                activeSlide = slide;
              }
            }
          });
        }

        // Update opacity and meta
        slides.forEach(slide => {
          slide.classList.remove('slide--active');
        });

        if (activeSlide) {
          activeSlide.classList.add('slide--active');
          const slideIndex = Array.from(slides).indexOf(activeSlide) + 1;
          updateSlideMeta(slideIndex, slides.length);
        } else if (slides.length > 0) {
          // Fallback: activate first slide
          slides[0].classList.add('slide--active');
          updateSlideMeta(1, slides.length);
        }
      }

      // Update on scroll
      let scrollTimeout;
      const handleScroll = () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(updateActiveSlide, 10);
      };
      
      window.addEventListener('scroll', handleScroll, { passive: true });
      window.addEventListener('resize', handleScroll, { passive: true });

      // Initial update - ensure first slide is active on load
      if (slides.length > 0) {
        slides[0].classList.add('slide--active');
        updateSlideMeta(1, slides.length);
      }
      
      // Also update after a short delay to ensure everything is rendered
      setTimeout(() => {
        updateActiveSlide();
      }, 100);
      
      setTimeout(() => {
        updateActiveSlide();
      }, 500);
    }

    // Set up dropdown functionality
    function setupDropdown() {
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.querySelector('.export-dropdown');
        if (dropdown && !dropdown.contains(e.target)) {
          closeDropdown();
        }
      });

      const exportBtn = document.getElementById('export-btn');
      if (exportBtn) {
        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleDropdown();
        });
      }

      document.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          const format = item.getAttribute('data-format');
          exportSlides(format);
        });
      });
    }

    // Global function to apply theme to slides
    function applyThemeToSlides(theme) {
      const slides = document.querySelectorAll('.slide');
      const slideCanvases = document.querySelectorAll('.slide__canvas');
      
      slides.forEach(slide => {
        if (theme === 'dark') {
          slide.classList.add('slide--dark');
          slide.classList.remove('slide--light');
        } else {
          slide.classList.remove('slide--dark');
          slide.classList.add('slide--light');
        }
      });

      slideCanvases.forEach(canvas => {
        if (theme === 'dark') {
          canvas.classList.add('slide__canvas--dark');
          canvas.classList.remove('slide__canvas--light');
        } else {
          canvas.classList.remove('slide__canvas--dark');
          canvas.classList.add('slide__canvas--light');
        }
      });
    }

    // Background theme functionality
    function setupBackgroundToolbar() {
      const backgroundBtn = document.getElementById('background-btn');
      const backgroundMenu = document.getElementById('background-menu');
      let currentTheme = localStorage.getItem('slide-theme') || 'light';

      // Apply saved theme
      applyThemeToSlides(currentTheme);
      updateDropdownStates(currentTheme);

      function toggleBackgroundMenu() {
        backgroundMenu.classList.toggle('show');
      }

      function closeBackgroundMenu() {
        backgroundMenu.classList.remove('show');
      }

      function updateDropdownStates(theme) {
        document.querySelectorAll('.toolbar-dropdown-item').forEach(item => {
          if (item.getAttribute('data-theme') === theme) {
            item.classList.add('active');
          } else {
            item.classList.remove('active');
          }
        });
      }

      function applyTheme(theme) {
        applyThemeToSlides(theme);
        updateDropdownStates(theme);
        localStorage.setItem('slide-theme', theme);
        currentTheme = theme;
      }

      backgroundBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleBackgroundMenu();
      });

      document.querySelectorAll('.toolbar-dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          const theme = item.getAttribute('data-theme');
          applyTheme(theme);
          closeBackgroundMenu();
        });
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.querySelector('.background-dropdown');
        if (dropdown && !dropdown.contains(e.target)) {
          closeBackgroundMenu();
        }
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      loadDeck();
      setupDropdown();
      setupBackgroundToolbar();
    });
  </script>
</body>
</html>